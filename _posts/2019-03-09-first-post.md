---
title: "C++에서의 예외처리 (1/2)"
date: 2019-03-09 16:40:00 -0800
categories: C++ Exception Exception_Handling
---

# 예외처리

##### 예외상황이란?

예외 상황이란 프로그램 실행 도중에 발생하는 문제 상황을 이야기 한다.
예를 들어보자 나이를 입력하라고 했는데 0보다 작은 값을 입력하거나, 나눗셈을 위해 두 개의
숫자를 입력 받았는데 이 중 분모로 들어오는 값이 0인 등의 상황을 이야기한다.

즉 코드를 예로 들어보겠다.

int main()
{
	int iNum1, iNum2;
	std::cout << "두 개의 숫자를 입력하시오 : ";
	std::cin>>iNum1>>iNum2;

	std::cout << "나눗셈의 몫 : " << iNum1 / iNum2 << std::endl;
	std::cout << "나눗셈의 나머지 : " << iNum1 % iNum2 << std::endl;

	return 0;
}

이런 경우 입력으로 11, 2를 넣는다면 몫으로 5 그리고 나머지로 1을 출력하는 정상적인 프로그램 실행이 
진행될 것이다. 하지만 만약 4 ,0을 넣는다면 더 이상 실행되지 않고 프로그램이 중단될 것이다.
(공학적으로 계산기에 분모로 0을 넣는다면 무한 루프가 되어 영원히 끝나지 않는 무한 반복을 하다가,
계산기가 맛이 갈 수 있다고 한다.)

이렇듯이 예외는 문법적인 오류가 아닌, 프로그램의 논리에 맞지 않는 오류를 말한다.
즉 예외 처리란 버그를 잡는 과정이 아닌 프로그램의 흐름을 끊을 수 있는 돌발 상황을 처리하는 과정을 의미한다.
(예외 처리는 문제 해결을 위한 것이 아닌 문제를 처리하는 과정에 불과하다는 것이다.)

##### if문을 이용한 예외의 처리

꼼꼼한 사람이라면 아마 위의 코드를 이런 식으로 썼을 것이다.

int main()
{
	int iNum1, iNum2;
	std::cout << "두 개의 숫자를 입력하시오 : ";
	std::cin>>iNum1>>iNum2;

	if(iNum2 == 0)
	{
		std::cout << "제수는 0이 될 수 없습니다." << std::endl;
		std::cout << "프로그램을 다시 실행하십시오." << std::endl;
	}
	else
	{
		std::cout << "나눗셈의 몫 : " << iNum1 / iNum2 << std::endl;
		std::cout << "나눗셈의 나머지 : " << iNum1 % iNum2 << std::endl;
	}

	return 0;
}

이런 식으로 쓴다면 적어도 예외는 처리되겠지만 일반적인 프로그램의 분기를 처리하기 위한 용도의 if문과
예외를 처리하기 위한 if문의 구별이 힘들 것이다. 즉 if문은 일반적으로 프로그램의 논리를 구현하는데
사용되기 때문에 C++, java같은 언어에서는 별도의 예외처리 매커니즘 즉 함수를 제공한다.

##### C++에서의 예외처리 매커니즘

대표적인 예외처리 키워드로는 try, catch, throw라는 키워드가 있다.
일단 간단하게 코드로 짜면 다음과 같다.

try {


	if(예외)
		throw expn;
} catch (type expn) {

}

try 블록은 예외발생에 대한 검사 범위를 지정하는데 사용되며, catch 블록은 try 블록에서 발생된 예외를
처리하는 데 사용되며 이때 catch는 throw로 던져진 예외 발생 알림을 보고 알게된다.
또한 try~catch는 하나의 문장이므로 그 사이에 다른 문장이 삽입될 수 없다.

다시 위의 코드로 돌아가보자. 위 코드는 다음과 같이 고칠 수 있다.

int main()
{
	int iNum1, iNum2;
	std::cout << "두 개의 숫자를 입력하시오 : ";
	std::cin >> iNum1 >> iNum2;

	try
	{
		if (iNum2 == 0)
			throw iNum2; // 잘못된 부분을 catch로 throw

		std::cout << "나눗셈의 몫 : " << iNum1 / iNum2 << std::endl;
		std::cout << "나눗셈의 나머지 : " << iNum1 % iNum2 << std::endl;
	}
	catch (int expn)
	{
		std::cout << "제수는 " << expn << "이 될 수 없습니다." << std::endl;
		std::cout << "프로그램을 다시 실행하십시오." << std::endl;
	}
	std::cout << "end of main" << std::endl;

	return 0;
}

이 코드에서 분모로 0을 입력한다면  catch문 안에 있는 명령어들이 실행되는 것을 알 수 있다. 
try문에서 만약 예외가 발생한다면 throw를 통해 catch로 가는 것을 확인할 수 있으며, try 안의
나머지 명령어들이 실행되지 않는 것을 확인할 수 있다.

즉 우리는 코드를 짜고 실행하면서 그 실행의 흐름을 이해하는 것이 중요하며 그 실행의 흐름이 
try 블록 안으로 들어가 예외 발생 시 이후에 등장하는 catch 블록을 실행하는 것을 확인 할 수 있고,
예외가 발생하지 않으면 try~catch 블록을 빠져 나와 try~catch 블록 이후를 실행하는 것을 확인할 수 있다.

※ 주의!!! 단 이런 식으로 묶으면 안 된다!!!!

try
{
	if (iNum2 == 0)
		throw iNum2;
}
catch (int expn)
{
	std::cout << "제수는 " << expn << "이 될 수 없습니다." << std::endl;
	std::cout << "프로그램을 다시 실행하십시오." << std::endl;
}
std::cout << "나눗셈의 몫 : " << iNum1 / iNum2 << std::endl;
std::cout << "나눗셈의 나머지 : " << iNum1 % iNum2 << std::endl;

이런 식으로 묶는 경우엔 iNum2가 0인 상태로 그대로 try~catch 블록을 빠져 나오기 때문에 그 상태(분모가 0인 상태)
그대로 프로그램이 실행되어 프로그램의 에러가 걸린다. 이를 방지하기 위해서 이런 식으로 쓰고 싶다면
catch문 안에서 iNum2를 다른 수로 처리를 하던지 아니면 처음부터 예외와 연관이 있는 부분을 모두 try 블록으로
묶는 것이 더 좋다.
